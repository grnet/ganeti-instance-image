#!/bin/bash

# Copyright (C) 2010, 2011, 2012 Oregon State University
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.

set -e
. ./common.sh
debug set -x

RUN_PARTS="`which run-parts`"
case "$IMAGE_TYPE" in
    tarball)
        IMG_EXT='.tar.gz'
        ;;
    qemu)
        IMG_EXT='.img'
        ;;
    dump)
        IMG_EXT='-root.dump'
        ;;
esac

if ! test -z "$IMAGE_URL"; then
    cd "$CACHE_DIR"
    if ! test -e "${CACHE_DIR}/${IMAGE_NAME}-${ARCH}$IMG_EXT"; then
        $WGET "${IMAGE_URL}/${IMAGE_NAME}-${ARCH}$IMG_EXT" >/dev/null 2>/dev/null || \
            { log_error "Failed to find the image on $IMAGE_URL"; exit 1; }
    fi
    if test 'yes' = "$IMG_VERIFY"; then
        $WGET "${IMAGE_URL}/${IMAGE_NAME}-${ARCH}${IMG_EXT}.sig" >/dev/null 2>/dev/null || \
            { log_error 'Failed to find the checksum file'; exit 1; }
        "$SHA1SUM" -c "${IMAGE_NAME}-${ARCH}${IMG_EXT}.sig" >/dev/null || \
            { log_error 'Image doesn'\''t match checksum!'; exit 1; }
    fi
    ! test 'yes' = "$IMG_CLEANUP" || \
        CLEANUP+=("rm -f \"${CACHE_DIR}/${IMAGE_NAME}-${ARCH}$IMG_EXT\" \"${CACHE_DIR}/${IMAGE_NAME}-${ARCH}${IMG_EXT}.sig\"")
    IMAGE_FILE="${CACHE_DIR}/${IMAGE_NAME}-${ARCH}$IMG_EXT"
    cd "$OLDPWD"
else
    IMAGE_FILE="${IMAGE_DIR}/${IMAGE_NAME}-${ARCH}$IMG_EXT"
fi

if test 'dump' = "$IMAGE_TYPE"; then
    # Workaround for restore's non-unique /tmp/rstdir* and /tmp/rstmode*
    TMPDIR="$(mktemp -d --tmpdir "${INSTANCE_NAME}_XXXXXXXX")"
    export TMPDIR
    CLEANUP+=("rmdir --ignore-fail-on-non-empty \"$TMPDIR\"")
fi

if test 'no' = "$CDINSTALL"; then
    # If the target device is not a real block device we'll first losetup it.
    # This is needed for file disks.
    if ! test -b "$BLOCKDEV"; then
        OLD_BLOCKDEV="$BLOCKDEV"
        BLOCKDEV="$("$LOSETUP" -sf "$BLOCKDEV")"
        CLEANUP+=("\"$LOSETUP\" -d \"$BLOCKDEV\"")
    fi

    DISK_SIZE="$(expr `"$BLOCKDEV_CMD" --getsize64 "$BLOCKDEV"` / 1048576)"

    if test 'yes' = "$SWAP"; then
        test -n "$SWAP_SIZE" || { log_error 'SWAP_SIZE not set however SWAP is enabled'; exit 1; }
        test $SWAP_SIZE -le $DISK_SIZE || \
            { log_error 'SWAP_SIZE larger than system disk size: '; log_error "  ${SWAP_SIZE}MB swap > ${DISK_SIZE}MB system disk"; exit 1; }
    fi

    test -f "$IMAGE_FILE" || { log_error "Can't find image file: $IMAGE_FILE"; exit 1; }

    # If the image is tarball based, then we need to manually create the
    # volumes, filesystems, etc
    if test 'tarball' = "$IMAGE_TYPE" || test 'dump' = "$IMAGE_TYPE"; then
        # Create 3 partitions, /boot, swap, & /
        format_disk0 "$BLOCKDEV"
    elif test 'qemu' = "$IMAGE_TYPE"; then
        # need a recent version of qemu for this
        "$QEMU_IMG" convert "$IMAGE_FILE" -O 'host_device' "$BLOCKDEV" >/dev/null
    fi

    # deploying something like a windows image, skip the rest
    ! test 'yes' = "$NOMOUNT" || { cleanup; exit 0; }

    if test -n "$RUN_PARTS" && test -d "$PRE_CUSTOMIZE_DIR"; then
        export TARGET SUITE BLOCKDEV IMAGE_TYPE
        "$RUN_PARTS" "$PRE_CUSTOMIZE_DIR"
    fi

    filesystem_dev="$(map_disk0)"
    CLEANUP+=('unmap_disk0')
    root_dev="$(map_partition "$filesystem_dev" root)"
    boot_dev="$(map_partition "$filesystem_dev" boot)"
    swap_dev="$(map_partition "$filesystem_dev" swap)"

    case "$IMAGE_TYPE" in
        tarball|dump)
            mkfs_disk0
            root_uuid="$(eval "$VOL_ID \"$root_dev\"")"
            test -n "$boot_dev" && sleep 1 && boot_uuid="$(eval "$VOL_ID \"$boot_dev\"")"
            test -n "$swap_dev" && sleep 1 && swap_uuid="$(eval "$VOL_ID \"$swap_dev\"")"
            ;;
    esac

    TARGET="`mktemp -d`"
    CLEANUP+=("rmdir \"$TARGET\"")

    # mount filesystems
    mount_disk0

    case "$IMAGE_TYPE" in
        tarball)
            # unpack image
            tar pzxf "$IMAGE_FILE" -C "$TARGET"
            ;;
        dump)
            root_dump="$IMAGE_FILE"
            ( cd "$TARGET"; restore -r -y -f "$root_dump" >/dev/null )
            if test -n "$boot_dev"; then
                boot_dump="${IMAGE_FILE%root.dump}boot.dump"
                test -f "$boot_dump" || { log_error "Can't find image file: $boot_dump"; exit 1; }
                ( cd "${TARGET}/boot"; restore -r -y -f "$boot_dump" >/dev/null )
            fi
            ;;
    esac

    case "$IMAGE_TYPE" in
        tarball|dump)
            setup_fstab
            ;;
    esac

    ! test 'True' = "$INSTANCE_HV_serial_console" || setup_console

    filesystem_check

    if test -n "$RUN_PARTS" && test -d "$CUSTOMIZE_DIR"; then
        ROOT_DEV="$root_dev"; BOOT_DEV="$boot_dev"; IMG_SSH_KEY_URL="$IMG_SSH_KEY_URL"
        export TARGET SUITE BLOCKDEV ROOT_DEV BOOT_DEV IMAGE_TYPE IMG_SSH_KEY_URL
        "$RUN_PARTS" "$CUSTOMIZE_DIR"
    fi
fi

# execute cleanups
cleanup
trap - EXIT
