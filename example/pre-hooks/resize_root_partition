#!/bin/bash

# Copyright (C) 2014 GRNET S.A.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.
#

set -e
. ./common.sh
debug set -x

if [ "${IMAGE_TYPE}" = 'qemu' ]; then

    part_table() {
        local action="$1" # set, get
        # sfdisk -d seems to always output in 512-byte sectors regardless of -uX
        # (using -uS here anyway in case someone else's sfdisk has a different default)
        if [ 'set' = "$action" ]; then
            ${SFDISK} -L -uS ${BLOCKDEV} 2>/dev/null
        else
            ${SFDISK} -L -uS -d ${BLOCKDEV} 2>/dev/null
        fi
    }

    get_part_sizes() {
        local part_num="$1"
        part_table get | \
            sed -n -e '1,/^$/ b; p' | \
            sed -e "$(
                test -z "$root_part_num" || printf '%d q; ' `expr $part_num + 1`
            )"'s/^.*size= *\([0-9]\+\),.*$/\1/' | \
            tr '\n' ' '
    }

    part_size() {
        local action="$1" # reset, set, get
        local part_num="$2"
        if [ 'set' = "$action" ]; then
            local value="$3"
        else
            local value=
        fi
        part_table get | \
            sed -n -e '1,/^$/ b; p' | \
            if [ 'get' = "$action" ]; then
                sed -n -e "${part_num}"'! b; s/^.*size= *\([0-9]\+\),.*$/\1/; p; q'
            else
                sed -e "${part_num}"'! b; s/size= *[0-9]\+,/size=,'"${value}/" | \
                    part_table set
            fi
    }

    if which partprobe >/dev/null 2>&1; then
        PARTPROBE="`which partprobe`"
    else
        PARTPROBE="${BLOCKDEV_CMD} --rereadpt"
    fi

    # Set disk based on type of hypervisor
    disk=""
    if [ "${HYPERVISOR}" = "kvm" ] ; then
        disk="vda"
    else
        disk="xda"
    fi

    # Get destination disk size in 512-byte sectors
    device_size=`${BLOCKDEV_CMD} --getsz ${BLOCKDEV}`

    # Get list of assigned partition sizes in table
    part_sizes="`get_part_sizes`"

    # Calculate total size used by partitions
    used_size=0
    for part_size in ${part_sizes}; do
        used_size=`expr ${used_size} + ${part_size}`
    done

    # Abort if device too small
    if [ ${device_size} -lt ${used_size} ]; then
        printf 'Device size (%d sectors) is less than size used by partitions (%d sectors). Aborting.\n' "${device_size}" "${used_size}" >&2
        cleanup
        trap - EXIT
        exit 1
    fi

    # If device too big
    if [ ${device_size} -gt ${used_size} ]; then

        # Get root (final) partition number
        if [ "${SWAP}" = "yes" ] && [ -z "${KERNEL_PATH}" ] ; then
            part_num=3
        elif [ "${SWAP}" = "no" ] && [ -z "${KERNEL_PATH}" ] || [ "${SWAP}" = "yes" ] && [ -n "${KERNEL_PATH}" ] ; then
            part_num=2
        elif [ "${SWAP}" = "no" ] && [ -n "${KERNEL_PATH}" ] ; then
            part_num=1
        fi

        # Expand (maximise) final partition
        part_size reset $part_num

        filesystem_dev=$(map_disk0 ${BLOCKDEV})
        CLEANUP+=("unmap_disk0 ${BLOCKDEV}")
        ROOT_DEV=$(map_partition $filesystem_dev root)

        # Expand filesystem on final partition
        #TODO: equivalent commandlines for btrfs, xfs, zfs, ntfs, etc...
        case `${BLKID} -p -u filesystem -s TYPE -o value ${ROOT_DEV}` in
            ext2|ext3|ext4)
                resize2fs -f ${ROOT_DEV} >/dev/null 2>&1
                e2fsck -f -n ${ROOT_DEV} >/dev/null 2>&1
                ;;
        esac

    fi
fi

cleanup
trap - EXIT
exit 0
